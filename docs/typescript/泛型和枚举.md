# 泛型和枚举

* 不用泛型的例子
```js
function identity(arg: number): number {
    return arg;
}
//或者，我们使用any类型来定义函数：
function identity(arg: any): any {
    return arg;
}
```
* 使用泛型的形式
```js
function identity<T>(arg: T): T {
    return arg;
}
```
* 定义了泛型函数后，可以用两种方法使用 
```js
// 1. 传入所有的参数，包含类型参数
let output = identity<string>("myString");  // type of output will be 'string'
// 2. 利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定的类型：
let output = identity("myString");  // type of output will be 'string'
```
* 注意点：
```js
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
//
function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
```

# 枚举
TypeScript支持数字的和基于字符串的枚举。

### 数字枚举

```js
//Up的值为 0， Down的值为 1等等。
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
```

我们定义了一个数字枚举， Up使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Direction.Up的值为 1， Down为 2， Left为 3， Right为 4
```js
enum Direction {
    Up = 1,
    Down,
    Left,
    Right
}
```
通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：
```js
enum Response {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: Response): void {
    // ...
}

respond("Princess Caroline", Response.Yes)
```
### 字符串枚举
```js
enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}
```
